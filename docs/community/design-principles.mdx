---
title: Design Principles
description: The core design principles that guide the development of the Model Context Protocol.
---

These principles guide how we evaluate proposals, weigh tradeoffs, and evolve MCP. They reflect lessons from building and maintaining the protocol. They are meant as guidance by and for the community when developing SEPs and extensions.

## Convergence over choice

MCP favors one well-designed way to accomplish something over multiple options that fragment the ecosystem. When faced with a decision between supporting multiple approaches or converging on a single path, we choose convergence. We accept the cost of harder decisions upfront to deliver a more cohesive protocol.

We are careful in considering new features in MCP, but lean into experimentation via [extensions](/community/seps/2133-extensions).

## Composability over specificity

MCP provides foundational primitives: resources, tools, prompts, and tasks. We resist adding protocol features for individual use cases when those use cases can be constructed from existing building blocks. This discipline keeps the protocol small and the implementation surface minimal.

When someone asks "why doesn't MCP support X directly?", the answer is often "because you can build X with what MCP already provides". Extensions such as [MCP Apps](/extensions/apps/overview) capture the emerging patterns.

## Stability over velocity

Adding to a protocol as widely adopted as MCP is easy; removing from it is nearly impossible. Every addition becomes a permanent commitment, and every addition is cost for client implementers to support. We move deliberately, accepting that "no" today leaves the door open while "yes" closes it forever.

Contributors accustomed to rapid shipping may find this pace frustrating, but sustainable standards require sustainable decision-making. We optimize for decades, not quarters.

## Demonstration over deliberation

MCP values working implementations over theoretical debates. When evaluating proposals, we prioritize evidence from real-world usage over arguments about hypothetical scenarios. We encourage contributors to prototype, experiment, and demonstrate rather than design by committee. Implementation reveals unknown unknowns.

## Pragmatism over purity

MCP makes practical tradeoffs in service of adoption and usability. We don't pursue theoretical elegance at the cost of real-world utility. When a "correct" design creates friction for implementers, we consider whether a "good enough" design better serves the ecosystem. This means accepting some inconsistency, some historical accidents, and some decisions we might make differently with hindsight.

## Standardization over innovation

MCP's purpose is to standardize patterns that have already proven valuable, not to pioneer novel approaches. We look for existing conventions that work across multiple implementations and codify them â€” we don't invent new paradigms and hope they'll be adopted.

We encourage the use of [MCP extensions](/extensions/overview) as a way to experiment with new patterns that may eventually lead to standardization.
