---
title: Transports
---

<div id="enable-section-numbers" />

<Info>**Protocol Revision**: draft</Info>

MCP uses JSON-RPC to encode messages. JSON-RPC messages **MUST** be UTF-8 encoded.

The protocol currently defines the following standard transport mechanisms for client-server
communication:

1. [stdio](#stdio), communication over standard in and standard out
2. [Streamable HTTP](#streamable-http)
3. [WebSocket](#websocket)

Clients **SHOULD** support stdio whenever possible.

It is also possible for clients and servers to implement
[custom transports](#custom-transports) in a pluggable fashion.

## stdio

In the **stdio** transport:

- The client launches the MCP server as a subprocess.
- The server reads JSON-RPC messages from its standard input (`stdin`) and sends messages
  to its standard output (`stdout`).
- Messages are individual JSON-RPC requests, notifications, or responses.
- Messages are delimited by newlines, and **MUST NOT** contain embedded newlines.
- The server **MAY** write UTF-8 strings to its standard error (`stderr`) for logging
  purposes. Clients **MAY** capture, forward, or ignore this logging.
- The server **MUST NOT** write anything to its `stdout` that is not a valid MCP message.
- The client **MUST NOT** write anything to the server's `stdin` that is not a valid MCP
  message.

```mermaid
sequenceDiagram
    participant Client
    participant Server Process

    Client->>+Server Process: Launch subprocess
    loop Message Exchange
        Client->>Server Process: Write to stdin
        Server Process->>Client: Write to stdout
        Server Process--)Client: Optional logs on stderr
    end
    Client->>Server Process: Close stdin, terminate subprocess
    deactivate Server Process
```

## Streamable HTTP

<Info>

This replaces the [HTTP+SSE
transport](/specification/2024-11-05/basic/transports#http-with-sse) from
protocol version 2024-11-05. See the [backwards compatibility](#backwards-compatibility)
guide below.

</Info>

In the **Streamable HTTP** transport, the server operates as an independent process that
can handle multiple client connections. This transport uses HTTP POST and GET requests.
Server can optionally make use of
[Server-Sent Events](https://en.wikipedia.org/wiki/Server-sent_events) (SSE) to stream
multiple server messages. This permits basic MCP servers, as well as more feature-rich
servers supporting streaming and server-to-client notifications and requests.

The server **MUST** provide a single HTTP endpoint path (hereafter referred to as the
**MCP endpoint**) that supports both POST and GET methods. For example, this could be a
URL like `https://example.com/mcp`.

#### Security Warning

When implementing Streamable HTTP transport:

1. Servers **MUST** validate the `Origin` header on all incoming connections to prevent DNS rebinding attacks
   - If the `Origin` header is present and invalid, servers **MUST** respond with HTTP 403 Forbidden. The HTTP response
     body **MAY** comprise a JSON-RPC _error response_ that has no `id`
2. When running locally, servers **SHOULD** bind only to localhost (127.0.0.1) rather than all network interfaces (0.0.0.0)
3. Servers **SHOULD** implement proper authentication for all connections

Without these protections, attackers could use DNS rebinding to interact with local MCP servers from remote websites.

### Sending Messages to the Server

Every JSON-RPC message sent from the client **MUST** be a new HTTP POST request to the
MCP endpoint.

1. The client **MUST** use HTTP POST to send JSON-RPC messages to the MCP endpoint.
2. The client **MUST** include an `Accept` header, listing both `application/json` and
   `text/event-stream` as supported content types.
3. The body of the POST request **MUST** be a single JSON-RPC _request_, _notification_, or _response_.
4. If the input is a JSON-RPC _response_ or _notification_:
   - If the server accepts the input, the server **MUST** return HTTP status code 202
     Accepted with no body.
   - If the server cannot accept the input, it **MUST** return an HTTP error status code
     (e.g., 400 Bad Request). The HTTP response body **MAY** comprise a JSON-RPC _error
     response_ that has no `id`.
5. If the input is a JSON-RPC _request_, the server **MUST** either
   return `Content-Type: text/event-stream`, to initiate an SSE stream, or
   `Content-Type: application/json`, to return one JSON object. The client **MUST**
   support both these cases.
6. If the server initiates an SSE stream:
   - The SSE stream **SHOULD** eventually include JSON-RPC _response_ for the
     JSON-RPC _request_ sent in the POST body.
   - The server **MAY** send JSON-RPC _requests_ and _notifications_ before sending the
     JSON-RPC _response_. These messages **SHOULD** relate to the originating client
     _request_.
   - The server **SHOULD NOT** close the SSE stream before sending the JSON-RPC _response_
     for the received JSON-RPC _request_, unless the [session](#session-management)
     expires.
   - After the JSON-RPC _response_ has been sent, the server **SHOULD** close the SSE
     stream.
   - Disconnection **MAY** occur at any time (e.g., due to network conditions).
     Therefore:
     - Disconnection **SHOULD NOT** be interpreted as the client cancelling its request.
     - To cancel, the client **SHOULD** explicitly send an MCP `CancelledNotification`.
     - To avoid message loss due to disconnection, the server **MAY** make the stream
       [resumable](#resumability-and-redelivery).

### Listening for Messages from the Server

1. The client **MAY** issue an HTTP GET to the MCP endpoint. This can be used to open an
   SSE stream, allowing the server to communicate to the client, without the client first
   sending data via HTTP POST.
2. The client **MUST** include an `Accept` header, listing `text/event-stream` as a
   supported content type.
3. The server **MUST** either return `Content-Type: text/event-stream` in response to
   this HTTP GET, or else return HTTP 405 Method Not Allowed, indicating that the server
   does not offer an SSE stream at this endpoint.
4. If the server initiates an SSE stream:
   - The server **MAY** send JSON-RPC _requests_ and _notifications_ on the stream.
   - These messages **SHOULD** be unrelated to any concurrently-running JSON-RPC
     _request_ from the client.
   - The server **MUST NOT** send a JSON-RPC _response_ on the stream **unless**
     [resuming](#resumability-and-redelivery) a stream associated with a previous client
     request.
   - The server **MAY** close the SSE stream at any time.
   - The client **MAY** close the SSE stream at any time.

### Multiple Connections

1. The client **MAY** remain connected to multiple SSE streams simultaneously.
2. The server **MUST** send each of its JSON-RPC messages on only one of the connected
   streams; that is, it **MUST NOT** broadcast the same message across multiple streams.
   - The risk of message loss **MAY** be mitigated by making the stream
     [resumable](#resumability-and-redelivery).

### Resumability and Redelivery

To support resuming broken connections, and redelivering messages that might otherwise be
lost:

1. Servers **MAY** attach an `id` field to their SSE events, as described in the
   [SSE standard](https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation).
   - If present, the ID **MUST** be globally unique across all streams within that
     [session](#session-management)â€”or all streams with that specific client, if session
     management is not in use.
2. If the client wishes to resume after a broken connection, it **SHOULD** issue an HTTP
   GET to the MCP endpoint, and include the
   [`Last-Event-ID`](https://html.spec.whatwg.org/multipage/server-sent-events.html#the-last-event-id-header)
   header to indicate the last event ID it received.
   - The server **MAY** use this header to replay messages that would have been sent
     after the last event ID, _on the stream that was disconnected_, and to resume the
     stream from that point.
   - The server **MUST NOT** replay messages that would have been delivered on a
     different stream.

In other words, these event IDs should be assigned by servers on a _per-stream_ basis, to
act as a cursor within that particular stream.

### Session Management

An MCP "session" consists of logically related interactions between a client and a
server, beginning with the [initialization phase](/specification/draft/basic/lifecycle). To support
servers which want to establish stateful sessions:

1. A server using the Streamable HTTP transport **MAY** assign a session ID at
   initialization time, by including it in an `Mcp-Session-Id` header on the HTTP
   response containing the `InitializeResult`.
   - The session ID **SHOULD** be globally unique and cryptographically secure (e.g., a
     securely generated UUID, a JWT, or a cryptographic hash).
   - The session ID **MUST** only contain visible ASCII characters (ranging from 0x21 to
     0x7E).
2. If an `Mcp-Session-Id` is returned by the server during initialization, clients using
   the Streamable HTTP transport **MUST** include it in the `Mcp-Session-Id` header on
   all of their subsequent HTTP requests.
   - Servers that require a session ID **SHOULD** respond to requests without an
     `Mcp-Session-Id` header (other than initialization) with HTTP 400 Bad Request.
3. The server **MAY** terminate the session at any time, after which it **MUST** respond
   to requests containing that session ID with HTTP 404 Not Found.
4. When a client receives HTTP 404 in response to a request containing an
   `Mcp-Session-Id`, it **MUST** start a new session by sending a new `InitializeRequest`
   without a session ID attached.
5. Clients that no longer need a particular session (e.g., because the user is leaving
   the client application) **SHOULD** send an HTTP DELETE to the MCP endpoint with the
   `Mcp-Session-Id` header, to explicitly terminate the session.
   - The server **MAY** respond to this request with HTTP 405 Method Not Allowed,
     indicating that the server does not allow clients to terminate sessions.

### Sequence Diagram

```mermaid
sequenceDiagram
    participant Client
    participant Server

    note over Client, Server: initialization

    Client->>+Server: POST InitializeRequest
    Server->>-Client: InitializeResponse<br>Mcp-Session-Id: 1868a90c...

    Client->>+Server: POST InitializedNotification<br>Mcp-Session-Id: 1868a90c...
    Server->>-Client: 202 Accepted

    note over Client, Server: client requests
    Client->>+Server: POST ... request ...<br>Mcp-Session-Id: 1868a90c...

    alt single HTTP response
      Server->>Client: ... response ...
    else server opens SSE stream
      loop while connection remains open
          Server-)Client: ... SSE messages from server ...
      end
      Server-)Client: SSE event: ... response ...
    end
    deactivate Server

    note over Client, Server: client notifications/responses
    Client->>+Server: POST ... notification/response ...<br>Mcp-Session-Id: 1868a90c...
    Server->>-Client: 202 Accepted

    note over Client, Server: server requests
    Client->>+Server: GET<br>Mcp-Session-Id: 1868a90c...
    loop while connection remains open
        Server-)Client: ... SSE messages from server ...
    end
    deactivate Server

```

### Protocol Version Header

If using HTTP, the client **MUST** include the `MCP-Protocol-Version:
<protocol-version>` HTTP header on all subsequent requests to the MCP
server, allowing the MCP server to respond based on the MCP protocol version.

For example: `MCP-Protocol-Version: 2025-06-18`

The protocol version sent by the client **SHOULD** be the one [negotiated during
initialization](/specification/draft/basic/lifecycle#version-negotiation).

For backwards compatibility, if the server does _not_ receive an `MCP-Protocol-Version`
header, and has no other way to identify the version - for example, by relying on the
protocol version negotiated during initialization - the server **SHOULD** assume protocol
version `2025-03-26`.

If the server receives a request with an invalid or unsupported
`MCP-Protocol-Version`, it **MUST** respond with `400 Bad Request`.

### Backwards Compatibility

Clients and servers can maintain backwards compatibility with the deprecated [HTTP+SSE
transport](/specification/2024-11-05/basic/transports#http-with-sse) (from
protocol version 2024-11-05) as follows:

**Servers** wanting to support older clients should:

- Continue to host both the SSE and POST endpoints of the old transport, alongside the
  new "MCP endpoint" defined for the Streamable HTTP transport.
  - It is also possible to combine the old POST endpoint and the new MCP endpoint, but
    this may introduce unneeded complexity.

**Clients** wanting to support older servers should:

1. Accept an MCP server URL from the user, which may point to either a server using the
   old transport or the new transport.
2. Attempt to POST an `InitializeRequest` to the server URL, with an `Accept` header as
   defined above:
   - If it succeeds, the client can assume this is a server supporting the new Streamable
     HTTP transport.
   - If it fails with an HTTP 4xx status code (e.g., 405 Method Not Allowed or 404 Not
     Found):
     - Issue a GET request to the server URL, expecting that this will open an SSE stream
       and return an `endpoint` event as the first event.
     - When the `endpoint` event arrives, the client can assume this is a server running
       the old HTTP+SSE transport, and should use that transport for all subsequent
       communication.

## WebSocket

This section defines bidirectional transport of MCP over a WebSocket connection which provides better support for maintaining long-lived sessions in spite of connection disruptions, particularly in cloud environments and through intermediaries. Long-lived session state that survives reconnection are necessary for server-initiated notifications like `notifications/resources/updated` and `notifications/*/list_changed` which enable real-time use cases.

The server **MUST** provide an HTTP endpoint path that supports WebSocket upgrade HTTP request. This **MAY** be the same endpoint as the Streamable HTTP transport.

### Message Handling

All messages **MUST** be sent as UTF-8 encoded text frames. Binary frames are not supported and **MUST** result in connection termination with close code `1003` (Unsupported Data).

### MCP Session Management for WebSockets

An MCP "session" consists of logically related interactions between a client and a
server, beginning with the [initialization phase](/specification/draft/basic/lifecycle).

- If the server does not support MCP sessions, it **MUST** omit this field.
- If the server wishes to support MCP sessions, it **MUST** assign an MCP session ID in response to an `initialize` call, by including a `result.mcpSessionId` field in the JSON-RPC response.
  - The session ID **SHOULD** be globally unique and cryptographically secure (e.g., a securely generated UUID, a JWT, or a cryptographic hash).
  - The session ID **MUST** only contain visible ASCII characters (ranging from 0x21 to 0x7E).
- Clients who wish the server to maintain state using the WebSocket transport **MUST** include the `params.mcpSessionId` field in all of their subsequent MCP communications.
- The server **MAY** terminate the session at any time, after which it **MUST** respond to requests containing that `mcpSessionId` with a JSON-RPC error code `-32602` and message "Invalid mcpSessionId".
- The server **MUST** include a `params.mcpSessionId` field in all of its MCP communications related to that session.
- The relationship of MCP sessions to WebSocket connections is many to one, so:
  - multiple sessions **MAY** share the same connection
  - there **MUST** only be one active connection for a particular session
  - clients **MAY** create additional MCP sessions on the same connection by calling `initialize` without a `params.mcpSessionId`
- Subscriptions (e.g. `resources/subscribe`, `list_changed`, etc.) are associated with a particular session so server-initiated notifications **MUST** only be sent over the active connection for that session.
- Clients **MAY** renegotiate version and capabilities for a given session at any time by sending a new `initialize` message with the desired parameters and including `params.mcpSessionId`.

### WebSocket Transport Lifecycle

#### Initial Connection and Session Establishment

**Client Behavior:**
- Send initial HTTP GET WebSocket upgrade request. Not all WebSocket clients (e.g. browsers) have direct access to headers for the initial HTTP GET WebSocket upgrade request but they all have access to the subprotocols list which gets included in the `Sec-WebSocket-Protocol` header. Therefore this WebSocket transport mimics the behavior of the Streamable HTTP transport by:
  - Clients **MUST** include an `mcp` string as the first entry in the WebSocket subprotocol list
  - Clients *MUST* include an `mcp.auth.${token}` string in WebSocket subprotocol list (see [Authorization](#authorization) for details)
  - Clients *MUST* include an `mcp.version.${protocolVersion}` value in the subprotocols list with the latest version supported by the client.
- Await acceptance or rejection response
- If accepted, establish MCP session by sending `initialize` without `mcpSessionId`

**Server Behavior:**
- Receive HTTP GET WebSocket upgrade request with auth token and protocol version in subprotocols list
- If auth fails, reject the WebSocket upgrade request
- If auth succeeds, accept the WebSocket connection
- Await the completion of the initialization phase before processing any other messages

#### Normal Operation

During normal operation:
- For session-specific communications, the client **MUST** include the `params.mcpSessionId` in all messages except the first `initialize`
- Server maintains session state and processes requests normally

#### Unintended Disconnection Handling

WebSocket connection interruption might occur at any time (e.g., due to network conditions). Therefore:
- WebSocket connection interruption **MUST NOT** be interpreted as the client cancelling an ongoing request
- To cancel, the client **SHOULD** explicitly send an MCP `CancelledNotification`
- Similarly, disconnection **MUST NOT** be interpreted as terminating the MCP sessions associated with the connection
- Server **MUST** preserve the state of any sessions associated with this connection for a reasonable timeout period to allow reconnection

#### Reconnection and Session Recovery

To reconnect:
- Client **MAY** include one `mcp.session-id.${mcpSessionId}` value in the WebSocket subprotocols list via the `Sec-WebSocket-Protocol` header in the WebSocket upgrade request to help with session affinity
- Client **MUST** include `mcp.auth.${token}` in the WebSocket subprotocols list
- Server **MUST** validate auth before proceeding. Auth is associated with the connection, not a particular session
- For subsequent session-specific communication, the client **MUST** include the `params.mcpSessionId` from the previous session in any message after reconnection
- Client **MAY** send an `initialize` message including a `params.mcpSessionId` after reconnecting over a different WebSocket connection to an existing session. If it does:
  - Server **MUST** associate this new connection with that session and update any renegotiated version or capabilities
  - Client **MAY** include a `params.lastEventId` in the `initialize` message. If it does:
    - After responding to the `initialize` call, the server **MUST** send the missed notifications from that event ID
    - The client **SHOULD NOT** send the `notifications/initialized` message to the server until it has received all missed notifications
- Even if the reconnecting client does not reinitialize but includes a `params.mcpSessionId` in any message, the server **MUST** make this the only active connection for the session
- Server **MUST** disassociate any previous connection associated with the same `mcpSessionId` and ignore any messages that arrive for that MCP session on any connection but the active one
- Server **SHOULD** keep track of recently disassociated connection-session pairs to prevent thrashing of a session between two connections
- If no other sessions are active on the recently disassociated connection, the server **SHOULD** close that connection with a `1000` "Normal Closure" status code
- Normal operation can resume

#### Intentional Connection Close Handling

- The server or client **MAY** close the WebSocket connection at any time by sending a close frame with an appropriate close code and reason.
- Session termination is independent of connection. So, the server **SHOULD NOT** automatically terminate sessions associated with the connection being closed.

### Error Handling

#### HTTP to WS Upgrade Errors

Servers **MUST** return appropriate HTTP status codes during WebSocket upgrade failures:

- `404 Not Found`: WebSocket endpoint not found

#### WebSocket Protocol Errors

The only way to communicate errors at the WebSocket protocol level is to terminate the connection with a close code and an optional reason. These include:

- `1003` "Unsupported Data" 

#### JSON-RPC Errors

The JSON-RPC errors specified in this WebSockets transport section are related to sessions as described above including:

- `-32602` "Missing mcpSessionId"
- `-32602` "Invalid mcpSessionId"

### Security

**Warning: MCP session is not a security mechanism**. It does not provide authentication or authorization. This specification defines MCP session management for reconnection, which is orthogonal to user authentication and authorization.

When implementing WebSocket transport:
1. Servers **MUST** validate the `Origin` header on all incoming WebSocket upgrade requests to prevent Cross-Site WebSocket Hijacking and DNS rebinding attacks
2. When running locally, servers **SHOULD** bind only to localhost (127.0.0.1) rather than all network interfaces (0.0.0.0)
3. Servers **SHOULD** implement proper authentication for all connections

Refer to [Authorization](/specification/draft/basic/authorization) for guidance on how to implement authorization for HTTP and WebSocket transports with the noted difference that the WebSocket transport smuggles in the auth token within the list of subprotocols provided by the client (which ends up in "Sec-WebSocket-Protocol" header) rather than by directly setting the "Authorization" header due to the inaccessibility of headers in the browser WebSocket API.

## Custom Transports

Clients and servers **MAY** implement additional custom transport mechanisms to suit
their specific needs. The protocol is transport-agnostic and can be implemented over any
communication channel that supports bidirectional message exchange.

Implementers who choose to support custom transports **MUST** ensure they preserve the
JSON-RPC message format and lifecycle requirements defined by MCP. Custom transports
**SHOULD** document their specific connection establishment and message exchange patterns
to aid interoperability.
